// SPDX-FileCopyrightText: OpenTalk GmbH <mail@opentalk.eu>
//
// SPDX-License-Identifier: EUPL-1.2

//! Resumption tokens are generated by the start endpoint and refreshed by the websocket runner.
//!
//! On start the frontend will be provided with the token in the response.
//!
//! In the case that the websocket disconnects the resumption token can be used by the frontend
//! to receive the same participant when reconnecting to the room. This enables all participant id
//! based features to recognize the reconnected client as the previously disconnected one.

use anyhow::{bail, Context, Result};
use redis_args::{FromRedisValue, ToRedisArgs};
use serde::{Deserialize, Serialize};
use signaling_core::{Participant, RedisConnection};
use std::time::{Duration, Instant};
use tokio::time::sleep_until;
use types::core::{BreakoutRoomId, ParticipantId, ResumptionToken, RoomId, UserId};

/// Redis key for a resumption token containing [`ResumptionData`].
#[derive(Debug, ToRedisArgs)]
#[to_redis_args(fmt = "opentalk-signaling:resumption={}")]
pub struct ResumptionRedisKey(pub ResumptionToken);

/// Data saved in redis behind the [`ResumptionRedisKey`]
#[derive(Debug, Serialize, Deserialize, ToRedisArgs, FromRedisValue)]
#[to_redis_args(serde)]
#[from_redis_value(serde)]
pub struct ResumptionData {
    pub participant_id: ParticipantId,
    pub participant: Participant<UserId>,
    pub room: RoomId,
    pub breakout_room: Option<BreakoutRoomId>,
}

/// Token refresh loop used in websocket runner to keep the resumption token alive and valid
pub struct ResumptionTokenKeepAlive {
    redis_key: ResumptionRedisKey,
    data: ResumptionData,
    next_refresh: Instant,
}

#[derive(Debug, thiserror::Error)]
#[error("resumption token could not be refreshed as it was used")]
pub struct ResumptionTokenUsed(());

impl ResumptionTokenKeepAlive {
    pub fn new(token: ResumptionToken, data: ResumptionData) -> Self {
        Self {
            redis_key: ResumptionRedisKey(token),
            data,
            next_refresh: Instant::now() + Duration::from_secs(60),
        }
    }

    pub async fn set_initial(&mut self, redis_conn: &mut RedisConnection) -> Result<()> {
        redis::cmd("SET")
            .arg(&self.redis_key)
            .arg(&self.data)
            .arg("EX")
            .arg(120)
            .arg("NX")
            .query_async(redis_conn)
            .await
            .context("failed to set initial resumption token")
    }

    pub async fn wait(&mut self) {
        sleep_until(self.next_refresh.into()).await;
    }

    pub async fn refresh(&mut self, redis_conn: &mut RedisConnection) -> Result<()> {
        self.next_refresh = Instant::now() + Duration::from_secs(60);

        // Set the value with an timeout of 120 seconds (EX 120)
        // and only if it already exists
        let value: redis::Value = redis::cmd("SET")
            .arg(&self.redis_key)
            .arg(&self.data)
            .arg("EX")
            .arg(120)
            .arg("XX")
            .query_async(redis_conn)
            .await
            .context("failed to SET EX XX resumption data")?;

        match value {
            redis::Value::Nil => bail!(ResumptionTokenUsed(())),
            redis::Value::Okay => Ok(()),
            _ => bail!("unexpected redis response expected OK/nil got {:?}", value),
        }
    }
}

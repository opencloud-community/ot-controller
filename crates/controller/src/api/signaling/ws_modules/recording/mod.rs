use crate::api::signaling::prelude::*;
use crate::api::Participant;
use anyhow::Result;
use controller_shared::ParticipantId;
use serde::{Deserialize, Serialize};

mod incoming;
mod outgoing;
mod rabbitmq;
mod storage;

pub struct Recording {
    id: ParticipantId,
    room: SignalingRoomId,
    i_am_the_recorder: bool,
    params: RecordingParams,
}

/// A recording id generated by the recording service
///
/// Is used for subsequent requests to a specific recording session
// TODO(kbalt): currently hacky workaround using the participant id as recording id
#[derive(Debug, Copy, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct RecordingId(ParticipantId);

#[derive(Debug, Serialize)]
pub struct FrontendData(Option<storage::RecordingState>);

#[derive(Debug, Serialize)]
pub struct PeerFrontendData {
    consents_recording: bool,
}

#[derive(Clone)]
pub struct RecordingParams {
    pub queue: String,
}

#[async_trait::async_trait(?Send)]
impl SignalingModule for Recording {
    const NAMESPACE: &'static str = "recording";

    type Params = RecordingParams;

    type Incoming = incoming::Message;
    type Outgoing = outgoing::Message;
    type RabbitMqMessage = rabbitmq::Message;

    type ExtEvent = ();

    type FrontendData = FrontendData;
    type PeerFrontendData = PeerFrontendData;

    async fn init(
        ctx: InitContext<'_, Self>,
        params: &Self::Params,
        _protocol: &'static str,
    ) -> Result<Option<Self>> {
        Ok(Some(Self {
            id: ctx.participant_id(),
            room: ctx.room_id(),
            i_am_the_recorder: matches!(ctx.participant(), Participant::Recorder),
            params: params.clone(),
        }))
    }

    async fn on_event(
        &mut self,
        mut ctx: ModuleContext<'_, Self>,
        event: Event<'_, Self>,
    ) -> Result<()> {
        match event {
            Event::Joined {
                control_data: _,
                frontend_data,
                participants,
            } => {
                if self.i_am_the_recorder {
                    let recording_id = RecordingId(self.id);
                    storage::set_recording(ctx.redis_conn(), self.room, recording_id).await?;

                    ctx.rabbitmq_publish(
                        control::rabbitmq::current_room_exchange_name(self.room),
                        control::rabbitmq::room_all_routing_key().into(),
                        rabbitmq::Message::Started(recording_id),
                    );
                } else {
                    *frontend_data = Some(FrontendData(
                        storage::get_state(ctx.redis_conn(), self.room).await?,
                    ));
                }

                let participant_ids: Vec<ParticipantId> = participants.keys().copied().collect();

                let participant_consents: Vec<Option<bool>> =
                    control::storage::get_attribute_for_participants(
                        ctx.redis_conn(),
                        self.room,
                        "recording_consent",
                        &participant_ids,
                    )
                    .await?;

                for (id, consent) in participant_ids.into_iter().zip(participant_consents) {
                    if let Some(consent) = consent {
                        participants.insert(
                            id,
                            Some(PeerFrontendData {
                                consents_recording: consent,
                            }),
                        );
                    }
                }
            }
            Event::Leaving => {
                if self.i_am_the_recorder {
                    ctx.rabbitmq_publish(
                        control::rabbitmq::current_room_exchange_name(self.room),
                        control::rabbitmq::room_all_routing_key().into(),
                        rabbitmq::Message::Stopped(RecordingId(self.id)),
                    );
                }
            }
            Event::RaiseHand => {}
            Event::LowerHand => {}
            Event::ParticipantJoined(_, _) => {}
            Event::ParticipantLeft(_) => {}
            Event::ParticipantUpdated(_, _) => {}
            Event::WsMessage(msg) => {
                match msg {
                    incoming::Message::Start => {
                        if ctx.role() != Role::Moderator {
                            ctx.ws_send(outgoing::Message::Error(
                                outgoing::Error::InsufficientPermissions,
                            ));
                            return Ok(());
                        }

                        if !storage::try_init(ctx.redis_conn(), self.room).await? {
                            ctx.ws_send(outgoing::Message::Error(
                                outgoing::Error::AlreadyRecording,
                            ));
                            return Ok(());
                        }

                        ctx.rabbitmq_publish_any(
                            Some(String::new()), // empty string to send to the default rmq exchange
                            self.params.queue.clone(),
                            rabbitmq::StartRecording {
                                room: self.room.room_id(),
                                breakout: self.room.breakout_room_id(),
                            },
                        );
                    }
                    incoming::Message::Stop(incoming::Stop { recording_id }) => {
                        if ctx.role() != Role::Moderator {
                            ctx.ws_send(outgoing::Message::Error(
                                outgoing::Error::InsufficientPermissions,
                            ));
                            return Ok(());
                        }

                        if !matches!(
                            storage::get_state(ctx.redis_conn(), self.room).await?,
                            Some(storage::RecordingState::Recording(id)) if id == recording_id
                        ) {
                            ctx.ws_send(outgoing::Message::Error(
                                outgoing::Error::InvalidRecordingId,
                            ));
                            return Ok(());
                        }

                        ctx.rabbitmq_publish(
                            control::rabbitmq::current_room_exchange_name(self.room),
                            control::rabbitmq::room_participant_routing_key(recording_id.0),
                            rabbitmq::Message::Stop,
                        );
                    }
                    incoming::Message::SetConsent(incoming::SetConsent { consent }) => {
                        control::storage::set_attribute(
                            ctx.redis_conn(),
                            self.room,
                            self.id,
                            "recording_consent",
                            consent,
                        )
                        .await?;

                        ctx.invalidate_data();
                    }
                }
            }
            Event::RabbitMq(msg) => match msg {
                rabbitmq::Message::Stop => {
                    if self.i_am_the_recorder {
                        // TODO(kbalt): A bit of a nuclear solution to end the recording
                        ctx.exit(None);
                    }
                }
                rabbitmq::Message::Started(recording_id) => {
                    if !self.i_am_the_recorder {
                        ctx.ws_send(outgoing::Message::Started(outgoing::Started {
                            recording_id,
                        }));
                    }
                }
                rabbitmq::Message::Stopped(recording_id) => {
                    if !self.i_am_the_recorder {
                        ctx.ws_send(outgoing::Message::Stopped(outgoing::Stopped {
                            recording_id,
                        }));
                    }
                }
            },
            Event::Ext(_) => {}
        }

        Ok(())
    }

    async fn on_destroy(self, mut ctx: DestroyContext<'_>) {
        if let Err(e) = storage::del_state(ctx.redis_conn(), self.room).await {
            log::error!("failed to delete state, {:?}", e);
        }
    }
}

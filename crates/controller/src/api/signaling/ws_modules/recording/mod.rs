// SPDX-FileCopyrightText: OpenTalk GmbH <mail@opentalk.eu>
//
// SPDX-License-Identifier: EUPL-1.2

use crate::api::signaling::prelude::*;
use crate::api::Participant;
use anyhow::{Context, Result};
use lapin_pool::{RabbitMqChannel, RabbitMqPool};
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use types::{core::ParticipantId, signaling::Role};

use self::{incoming::RecordingCommand, outgoing::RecordingEvent};

mod exchange;
mod incoming;
mod outgoing;
mod rabbitmq;
mod storage;

pub struct Recording {
    id: ParticipantId,
    room: SignalingRoomId,
    i_am_the_recorder: bool,
    params: RecordingParams,

    /// RabbitMQ channel used to send the recording start command over
    rabbitmq_channel: RabbitMqChannel,
}

/// A recording id generated by the recording service
///
/// Is used for subsequent requests to a specific recording session
// TODO(kbalt): currently hacky workaround using the participant id as recording id
#[derive(Debug, Copy, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct RecordingId(ParticipantId);

#[derive(Debug, Serialize)]
pub struct FrontendData(Option<storage::RecordingState>);

#[derive(Debug, Serialize)]
pub struct PeerFrontendData {
    consents_recording: bool,
}

#[derive(Clone)]
pub struct RecordingParams {
    pub queue: String,
}

#[async_trait::async_trait(?Send)]
impl SignalingModule for Recording {
    const NAMESPACE: &'static str = "recording";

    type Params = (Arc<RabbitMqPool>, RecordingParams);

    type Incoming = RecordingCommand;
    type Outgoing = RecordingEvent;
    type ExchangeMessage = exchange::Message;

    type ExtEvent = ();

    type FrontendData = FrontendData;
    type PeerFrontendData = PeerFrontendData;

    async fn init(
        ctx: InitContext<'_, Self>,
        params: &Self::Params,
        _protocol: &'static str,
    ) -> Result<Option<Self>> {
        let (rabbitmq_pool, params) = params;

        let rabbitmq_channel = rabbitmq_pool.create_channel().await?;

        Ok(Some(Self {
            id: ctx.participant_id(),
            room: ctx.room_id(),
            i_am_the_recorder: matches!(ctx.participant(), Participant::Recorder),
            params: params.clone(),
            rabbitmq_channel,
        }))
    }

    async fn on_event(
        &mut self,
        mut ctx: ModuleContext<'_, Self>,
        event: Event<'_, Self>,
    ) -> Result<()> {
        match event {
            Event::Joined {
                control_data: _,
                frontend_data,
                participants,
            } => {
                if self.i_am_the_recorder {
                    let recording_id = RecordingId(self.id);
                    storage::set_recording(ctx.redis_conn(), self.room, recording_id).await?;

                    ctx.exchange_publish(
                        control::exchange::current_room_all_participants(self.room),
                        exchange::Message::Started(recording_id),
                    );
                } else {
                    *frontend_data = Some(FrontendData(
                        storage::get_state(ctx.redis_conn(), self.room).await?,
                    ));
                }

                let participant_ids: Vec<ParticipantId> = participants.keys().copied().collect();

                let participant_consents: Vec<Option<bool>> =
                    control::storage::get_attribute_for_participants(
                        ctx.redis_conn(),
                        self.room,
                        "recording_consent",
                        &participant_ids,
                    )
                    .await?;

                for (id, consent) in participant_ids.into_iter().zip(participant_consents) {
                    if let Some(consent) = consent {
                        participants.insert(
                            id,
                            Some(PeerFrontendData {
                                consents_recording: consent,
                            }),
                        );
                    }
                }
            }
            Event::Leaving => {
                if self.i_am_the_recorder {
                    ctx.exchange_publish(
                        control::exchange::current_room_all_participants(self.room),
                        exchange::Message::Stopped(RecordingId(self.id)),
                    );
                }
            }
            Event::RaiseHand => {}
            Event::LowerHand => {}
            Event::ParticipantLeft(_) => {}
            Event::ParticipantJoined(id, data) | Event::ParticipantUpdated(id, data) => {
                let consent: Option<bool> = control::storage::get_attribute(
                    ctx.redis_conn(),
                    self.room,
                    id,
                    "recording_consent",
                )
                .await?;

                if let Some(consent) = consent {
                    *data = Some(PeerFrontendData {
                        consents_recording: consent,
                    })
                }
            }
            Event::WsMessage(msg) => match msg {
                RecordingCommand::Start => {
                    if ctx.role() != Role::Moderator {
                        ctx.ws_send(RecordingEvent::Error(
                            outgoing::Error::InsufficientPermissions,
                        ));
                        return Ok(());
                    }

                    if !storage::try_init(ctx.redis_conn(), self.room).await? {
                        ctx.ws_send(RecordingEvent::Error(outgoing::Error::AlreadyRecording));
                        return Ok(());
                    }

                    self.rabbitmq_channel
                        .basic_publish(
                            "",
                            &self.params.queue,
                            Default::default(),
                            &serde_json::to_vec(&rabbitmq::StartRecording {
                                room: self.room.room_id(),
                                breakout: self.room.breakout_room_id(),
                            })
                            .context("failed to serialize StartRecording")?,
                            Default::default(),
                        )
                        .await?;
                }
                RecordingCommand::Stop(incoming::Stop { recording_id }) => {
                    if ctx.role() != Role::Moderator {
                        ctx.ws_send(RecordingEvent::Error(
                            outgoing::Error::InsufficientPermissions,
                        ));
                        return Ok(());
                    }

                    if !matches!(
                        storage::get_state(ctx.redis_conn(), self.room).await?,
                        Some(storage::RecordingState::Recording(id)) if id == recording_id
                    ) {
                        ctx.ws_send(RecordingEvent::Error(outgoing::Error::InvalidRecordingId));
                        return Ok(());
                    }

                    ctx.exchange_publish(
                        control::exchange::current_room_by_participant_id(
                            self.room,
                            recording_id.0,
                        ),
                        exchange::Message::Stop,
                    );
                }
                RecordingCommand::SetConsent(incoming::SetConsent { consent }) => {
                    control::storage::set_attribute(
                        ctx.redis_conn(),
                        self.room,
                        self.id,
                        "recording_consent",
                        consent,
                    )
                    .await?;

                    ctx.invalidate_data();
                }
            },
            Event::Exchange(msg) => match msg {
                exchange::Message::Stop => {
                    if self.i_am_the_recorder {
                        // TODO(kbalt): A bit of a nuclear solution to end the recording
                        ctx.exit(None);
                    }
                }
                exchange::Message::Started(recording_id) => {
                    if !self.i_am_the_recorder {
                        ctx.ws_send(RecordingEvent::Started(outgoing::Started { recording_id }));
                    }
                }
                exchange::Message::Stopped(recording_id) => {
                    if !self.i_am_the_recorder {
                        ctx.ws_send(RecordingEvent::Stopped(outgoing::Stopped { recording_id }));
                    }
                }
            },
            Event::Ext(_) => {}
        }

        Ok(())
    }

    async fn on_destroy(self, mut ctx: DestroyContext<'_>) {
        if self.i_am_the_recorder {
            if let Err(e) = storage::del_state(ctx.redis_conn(), self.room).await {
                log::error!("failed to delete state, {:?}", e);
            }
        }
    }
}

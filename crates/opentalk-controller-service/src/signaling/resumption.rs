// SPDX-FileCopyrightText: OpenTalk GmbH <mail@opentalk.eu>
//
// SPDX-License-Identifier: EUPL-1.2

//! Resumption tokens are generated by the start endpoint and refreshed by the websocket runner.
//!
//! On start the frontend will be provided with the token in the response.
//!
//! In the case that the websocket disconnects the resumption token can be used by the frontend
//! to receive the same participant when reconnecting to the room. This enables all participant id
//! based features to recognize the reconnected client as the previously disconnected one.

use std::time::{Duration, Instant};

use opentalk_signaling_core::Participant;
use opentalk_types_common::{
    auth::ResumptionToken,
    rooms::{BreakoutRoomId, RoomId},
    users::UserId,
};
use opentalk_types_signaling::ParticipantId;
use redis_args::{FromRedisValue, ToRedisArgs};
use serde::{Deserialize, Serialize};
use tokio::time::sleep_until;

use crate::{
    Result,
    signaling::storage::{SignalingStorage, SignalingStorageError},
};

const RESUMPTION_REFRESH_INTERVAL: u64 = 60;

/// Resumption data
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize, ToRedisArgs, FromRedisValue)]
#[to_redis_args(serde)]
#[from_redis_value(serde)]
pub struct ResumptionData {
    pub participant_id: ParticipantId,
    pub participant: Participant<UserId>,
    pub room: RoomId,
    pub breakout_room: Option<BreakoutRoomId>,
}

/// Token refresh loop used in websocket runner to keep the resumption token alive and valid

#[derive(Debug)]
pub struct ResumptionTokenKeepAlive {
    resumption_token: ResumptionToken,
    data: ResumptionData,
    next_refresh: Instant,
}

impl ResumptionTokenKeepAlive {
    pub fn new(resumption_token: ResumptionToken, data: ResumptionData) -> Self {
        Self {
            resumption_token,
            data,
            next_refresh: Instant::now() + Duration::from_secs(RESUMPTION_REFRESH_INTERVAL),
        }
    }

    pub async fn set_initial(
        &mut self,
        storage: &mut dyn SignalingStorage,
    ) -> Result<(), SignalingStorageError> {
        storage
            .set_resumption_token_data_if_not_exists(&self.resumption_token, &self.data)
            .await
    }

    pub async fn wait(&mut self) {
        sleep_until(self.next_refresh.into()).await;
    }

    pub async fn refresh(
        &mut self,
        storage: &mut dyn SignalingStorage,
    ) -> Result<(), SignalingStorageError> {
        self.next_refresh = Instant::now() + Duration::from_secs(RESUMPTION_REFRESH_INTERVAL);

        storage
            .refresh_resumption_token(&self.resumption_token)
            .await
    }
}
